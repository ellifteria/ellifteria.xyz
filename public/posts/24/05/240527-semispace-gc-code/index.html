
<!DOCTYPE html>
<html>

    <head>

        <meta charset="UTF-8">
        <link rel="stylesheet" href="/css/main.css">

        
    <title>ellifteria.xyz | Semi-Space Garbage Collection Part 2</title>


        

<script>
    if (typeof main === "undefined"){
        var main = function() {};
    }
</script>



        

<link rel="apple-touch-icon-precomposed" sizes="57x57" href="apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="apple-touch-icon-144x144.png" />
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="apple-touch-icon-152x152.png" />
<link rel="icon" type="image/png" href="favicon-196x196.png" sizes="196x196" />
<link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16" />
<link rel="icon" type="image/png" href="favicon-128.png" sizes="128x128" />
<meta name="application-name" content="&nbsp;"/>
<meta name="msapplication-TileColor" content="#FFFFFF" />
<meta name="msapplication-TileImage" content="mstile-144x144.png" />
<meta name="msapplication-square70x70logo" content="mstile-70x70.png" />
<meta name="msapplication-square150x150logo" content="mstile-150x150.png" />
<meta name="msapplication-wide310x150logo" content="mstile-310x150.png" />
<meta name="msapplication-square310x310logo" content="mstile-310x310.png" />


        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/color-brewer.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

        <script src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js/dist/highlightjs-line-numbers.min.js"></script>

    
    

        <script>hljs.highlightAll(); hljs.initLineNumbersOnLoad({singleLine: true});</script>

        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

        <style>


		td.hljs-ln-numbers {
			text-align: center;
			color: #ccc;
			border-right: 1px solid #999;
			vertical-align: top;
			padding-right: 5px;

			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		td.hljs-ln-code {
			padding-left: 10px;
		}

		code {
			white-space: pre-wrap;
			overflow: auto;
		}
	
        </style>
    </head>

    <body onload="main()">
        <header>
            

<div class="column">
    <div class="navigation">
        |
        
            
                <a href="/">Home</a> |
            
        
            
                <a href="/tiwo">TIWO</a> |
            
        
            
                <a href="/bookshelf">Bookshelf</a> |
            
        
            
                <a href="/posts">Posts</a> |
            
        
    </div>
    <div class="breadcrumb">
        <a href="/">ellifteria.xyz</a>
    </div>
</div>


        </header>
        
        <article>
            <section>
                

    
    <h1>Semi-Space Garbage Collection Part 2</h1>
    
    <p>
        Series: <a href="/posts/series/gc">Garbage Collection</a>
    </p>
    
    
    
        <div class="pathToPage">
            <p>
                <a href="/">~</a>
                
                    /
                    <strong>
                        
                        <a href="/posts" >Posts</a>
                        
                    </strong>
                
                    /
                    <strong>
                        
                        <a href="/posts/24/05/240527-semispace-gc-code" class="self">Semi-Space Garbage Collection Part 2</a>
                        
                    </strong>
                
            </p>
        </div>
    

    <p class="subtitle">A Deep Dive into Implementing a Two-Space Copying Garbage Collector</p>


    

<p><a href="../240523-semispace-gc">Last time</a>, we covered how semi-space garbage collection works using Cheney's algorithm.
Let's finally write some code!</p>
<h2 id="cheneys-algorithm-in-javascript">Cheney's Algorithm in JavaScript</h2>
<h3 id="provided-classes-and-functions">Provided Classes and Functions</h3>
<p>To make life easier for ourselves, let's assume we already have some classes defined<label for="sidenote--sn1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sidenote--sn1" class="margin-toggle"/><span class="sidenote">
They actually are already defined and can be found <a href="https://github.com/ellifteria/cheneys-gc.js/blob/main/GCLib.js">here</a>.
</span> defined.
First, we have a <code>Heap</code> class that provides the following methods:</p>
<ol>
<li><code>heapSet(address, value)</code>: Sets <code>address</code> in the heap to <code>value</code> if <code>address</code> is a valid address.</li>
<li><code>heapGet(address)</code>: Returns the value stored in <code>address</code> if it is a valid address.</li>
<li><code>heapFill(startAddress, endAddress, value)</code>: Fills all addresses between <code>startAddress</code> (inclusive) and <code>endAddress</code> (exclusive) with <code>value</code>.</li>
</ol>
<p>Next, we have a <code>Collector</code> class to represent an abstract garbage collector.
The <code>Collector</code> class has the following methods that all throw <code>not yet implemented</code> errors and need to be filled in by a class inheriting from <code>Collector</code></p>
<ol>
<li><code>collectGarbage(root1, root2)</code>: This is the method we'll call to actually collect garbage.</li>
<li><code>spaceExists(amount)</code>: This method should check if there's any space left in the heap or if we need to collect garbage.</li>
<li><code>allocate(data, asRoot = false)</code>: Here is where we'll allocate memory.</li>
</ol>
<p>It also contains the following methods that do have definitions:<label for="sidenote--sn2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sidenote--sn2" class="margin-toggle"/><span class="sidenote">
In our collector, we will be manually adding and removing roots. This is a very simplified way of thinking about program roots and is NOT how you would want to implement it in an actual programming language. We just do this here for simplicity's sake.
</span>:</p>
<ol>
<li><code>addRoot(root)</code>: Adds a new root to the collector's current root set.</li>
<li><code>removeRoot(root)</code>: Removes a root from the collector's root set</li>
<li><code>moveRoot(oldRoot, newRoot)</code>: Removes a root from the collector's root set and adds the new root.</li>
</ol>
<p>The <code>Collector</code> class also has a <code>constructor</code> that instantiates the root set.</p>
<p>Lastly, we have functions defined for integer division and checking if a value is an integer: <code>integerDivision(a, b)</code> which returns <span class="math inline">\(\left\lfloor \frac{a}{b} \right\rfloor\)</span> and <code>isInteger(maybeInteger)</code> which returns whether or not <code>maybeInteger</code> is an integer.</p>
<p>And with all of these, we're ready to start implementing Cheney's algorithm!</p>
<h3 id="instantiating-the-collector">Instantiating the Collector</h3>
<p>Let's start with the simplest part of the code:
instantiating the garbage collector.</p>
<p>Here, we have a couple of tasks.
We need to</p>
<ol>
<li>Create a <code>Heap</code> of memory</li>
<li>Set up any variables we need to allocate memory and collect garbage</li>
</ol>
<p>The first part is relatively simple and just relies on calling <code>new Heap(size)</code>.
This means that we need to get a size of our heap from whomever is instantiating the collector.
And if that's the case, we need to validate that the given <code>size</code> is a legal value.</p>
<p>That brings up our first question:
what sizes can we NOT have for our garbage collector?</p>
<p>To answer that, we need to think about how much memory our collector will 100% absolutely need.
Since we need to be able to allocate <em>some</em> memory, we can first say that <code>size</code> has to be greater than or equal to 1.
However, we also need to be able to copy memory from the From Space to the To Space.
As noted <a href="../240523-semispace-gc/">earlier</a>, we need to have the same amount of space in the From Space and the To Space, so now we need <code>size</code> to be at least 2.</p>
<p>Pause for a second here to think.
Is there any more memory we need?</p>
<p>Yes, there is.
In our last post, we mentioned that we needed to keep track of two pointers we called the <code>free</code> and the <code>scan</code> pointers.
These kept track of where we were in memory when collecting garbage.
We'll also keep track of two more pointers: one to the start of the To Space and one to the start of the From Space.
This brings us up to four pointers.
Since we also needed to have room for at least one thing in both the To Space and the From Space, we'll add <span class="math inline">\(4 + 2 = 6\)</span> and say that we need <code>size</code> to be at least 6<label for="sidenote--sn3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sidenote--sn3" class="margin-toggle"/><span class="sidenote">
For reasons that will become obvious later, 6 is actually too small to be able to allocate anything. This is because we'll need at least 2 address available for every piece of memory to store the object and the type of the object. You could choose to make <code>size</code> at least 8 if you want. We just absolutely need it to be at least 6 so we have separate addresses for the start of the To Space and the From Space.
</span>.</p>
<p>So, the first thing we should do is to check that <code>size</code> is valid and then instantiate our heap<label for="sidenote--sn4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sidenote--sn4" class="margin-toggle"/><span class="sidenote">
(after calling the <code>super</code> constructor, of course)
</span>!</p>
<pre><code class="language-js">constructor(size) {
    super();

    if (!isInteger(size) || size &lt;= 6) {
        console.error(`new Collector: illegal size: ${size}`);
        return null;
    }

    this.heap = new Heap(size);
    this.heap.healFill(0, size, &quot;free&quot;); // fill heap with empty memory

    ...
</code></pre>
<p>Ok, what's next?
We need to instantiate our four pointers.
First, we need to figure out where our From Space and To Space start.
The space available for memory is all the space after our pointers.
So we have <span class="math inline">\(size - 4\)</span> addresses available which means each the From Space and the To Space get <span class="math inline">\(\frac{size - 4}{2}\)</span> addresses.
We'll have the From Space start directly after the To Space: address 4.
That means that the To Space starts at <span class="math inline">\(4 + \frac{size - 4}{2}\)</span>, right?
Yes...
...unless we have an odd size.
In that case, if we divided the space evenly, one of the From and the To Space will be &quot;smaller&quot; than the other.
However, we know that won't work.
So, what should we do?</p>
<p>The solution:
ignore the single address that's making the size of the heap odd.
How do we do this mathematically?
Give the From Space and the To Space each <span class="math inline">\(\left\lfloor\frac{size - 4}{2}\right\rfloor\)</span> addresses.
So, we start the To Space at <span class="math inline">\(4 + \left\lfloor\frac{size - 4}{2}\right\rfloor\)</span>.
Since later we'll calculate the size of the To Space based on the size of the From Space, this means that the To Space will also have <span class="math inline">\(\left\lfloor\frac{size - 4}{2}\right\rfloor\)</span> addresses.</p>
<pre><code class="language-js">constructor(size) {
    ...

    let fromPointer = 4;
    let toPointer = integerDivision(size - 4, 2) + 4;

    ...
</code></pre>
<p>We need to store the values of these pointers in our heap so we can access them later.
We'll store them in this order:</p>
<ol>
<li>Pointer to the start of the From Space</li>
<li>Pointer to the start of the To Space</li>
<li>Allocation pointer (when not collecting garbage)/scan pointer (when collecting garbage)</li>
<li>MaxAllocation pointe (when not collecting garbage)/free pointer (when collecting garbage)</li>
</ol>
<p>We need to initialize these to:</p>
<ol>
<li>the pointer to the start of the From Space</li>
<li>the pointer to the start of the To Space</li>
<li>the pointer to the start of the From Space</li>
<li>the pointer to the start of the To Space</li>
</ol>
<pre><code class="language-js">constructor(size) {
    ...

    this.heap.heapSet(0, fromPointer);
    this.heap.heapSet(1, toPointer);
    this.heap.heapSet(2, fromPointer);
    this.heap.heapSet(3, toPointer);
}
</code></pre>
<p>This completes our constructor!</p>
<pre><code class="language-js">constructor(size) {
    super();

    if (!isInteger(size) || size &lt;= 6) {
        console.error(`new Collector: illegal size: ${size}`);
        return null;
    }

    this.heap = new Heap(size);
    this.heap.heapFill(0, size, &quot;free&quot;);

    let fromPointer = 4;
    let toPointer = integerDivision(size - 4, 2) + 4;
    
    this.heap.heapSet(0, fromPointer);
    this.heap.heapSet(1, toPointer);
    this.heap.heapSet(2, fromPointer);
    this.heap.heapSet(3, toPointer);

}
</code></pre>
<pre><code class="language-js">class TwoSpaceCopyingCollector extends Collector {
    constructor(size) {
        super();

        if (!isInteger(size) || size &lt;= 6) {
            console.error(`new Collector: illegal size: ${size}`);
            return null;
        }

        this.heap = new Heap(size);
        let fromPointer = 4;
        let toPointer = integerDivision(size - 4, 2) + 4;
        this.heap.heapFill(0, size, &quot;free&quot;);
        this.heap.heapSet(0, fromPointer);
        this.heap.heapSet(1, toPointer);
        this.heap.heapSet(2, fromPointer);
        this.heap.heapSet(3, toPointer);

    }
    
    copyFrom(pointer) {
        let freePointer = this.heap.heapGet(3);
        switch(this.heap.heapGet(pointer)) {
            case &quot;forward&quot;:
                return this.heap.heapGet(pointer + 1);
            case &quot;flat&quot;:
                this.heap.heapSet(freePointer, &quot;flat&quot;);
                this.heap.heapSet(freePointer + 1, this.heap.heapGet(pointer + 1));
                this.heap.heapSet(pointer, &quot;forward&quot;);
                this.heap.heapSet(pointer + 1, freePointer);
                this.heap.heapSet(3, freePointer + 2);
                break;
            case &quot;cons&quot;:
                this.heap.heapSet(freePointer, &quot;cons&quot;);
                this.heap.heapSet(freePointer + 1, this.heap.heapGet(pointer + 1));
                this.heap.heapSet(freePointer + 2, this.heap.heapGet(pointer + 2));
                this.heap.heapSet(pointer, &quot;forward&quot;);
                this.heap.heapSet(pointer + 1, freePointer);
                this.heap.heapSet(3, freePointer + 3);
                break;
            default:
                console.error(`Collector.copyFrom: unknown tag: ${this.heap.heapGet(pointer)}`);
                return null;
        }
        return freePointer;
    }
    
    collectGarbageStep() {
        let scanPointer = this.heap.heapGet(2);
        let tag = this.heap.heapGet(scanPointer);
        switch(tag) {
            case &quot;flat&quot;:
                this.heap.heapSet(2, scanPointer + 2);
                break;
            case &quot;cons&quot;:
                this.heap.heapSet(scanPointer + 1, this.copyFrom(this.heap.heapGet(scanPointer + 1)));
                this.heap.heapSet(scanPointer + 2, this.copyFrom(this.heap.heapGet(scanPointer + 2)));
                this.heap.heapSet(2, scanPointer + 3);
                break;
            default:
                console.error(`Collector.collectGarbage: unknown tag: ${tag}`);
                return null;
        }
    }
    
    collectGarbage(root1, root2) {
        this.heap.heapSet(2, this.heap.heapGet(1));
        this.heap.heapSet(3, this.heap.heapGet(1));
        
        let newRoot1 = false;
        let newRoot2 = false;

        let newRoots = new Set();
        
        if (root1 != false) {
            newRoot1 = this.copyFrom(root1);
            this.moveRoot(root1, newRoot1);
            newRoots.add(root1);
        }
        if (root2 != false) {
            newRoot2 = this.copyFrom(root2);
            this.moveRoot(root2, newRoot2);
            newRoots.add(root2);
        }

        let currentRoots = this.roots.difference(newRoots).values().toArray();
        for (const root of currentRoots) {
            let newRoot = this.copyFrom(root);
            this.moveRoot(root, newRoot);
        }
        
        while (this.heap.heapGet(2) &lt; this.heap.heapGet(3)) {
            this.collectGarbageStep();
        }

        this.cleanUpCollection();
        
        return [newRoot1, newRoot2];
    }
    
    cleanUpCollection() {
        let oldFromPointer = this.heap.heapGet(0);
        let oldToPointer = this.heap.heapGet(1);
        
        let availableAllocationSpace = Math.abs(oldToPointer - oldFromPointer);

        this.heap.heapFill(oldFromPointer, oldFromPointer + availableAllocationSpace, &quot;free&quot;);
        
        this.heap.heapSet(0, oldToPointer);
        this.heap.heapSet(1, oldFromPointer);
        
        if (oldToPointer &gt;= oldFromPointer) {
            this.heap.heapSet(3, (oldFromPointer - 4) * 2 + 4);
        } else {
            this.heap.heapSet(3, oldFromPointer);
        }
    }
    
    spaceExists(amount) {
        return this.heap.heapGet(3) &gt;= (this.heap.heapGet(2) + amount);
    }
    
    allocate(data, asRoot = false) {
        let allocationPointer = this.heap.heapGet(2);
        
        switch (data.tag) {
            case &quot;flat&quot;:
                if (this.spaceExists(2)) {
                    this.heap.heapSet(allocationPointer, &quot;flat&quot;);
                    this.heap.heapSet(allocationPointer + 1, data.value);
                    this.heap.heapSet(2, allocationPointer + 2);
                    if (asRoot) {
                        this.addRoot(allocationPointer);
                    }
                } else {
                    this.collectGarbage(false, false);
                    if (this.spaceExists(2)) {
                        allocationPointer = this.heap.heapGet(2);
                        this.heap.heapSet(allocationPointer, &quot;flat&quot;);
                        this.heap.heapSet(allocationPointer + 1, data.value);
                        this.heap.heapSet(2, allocationPointer + 2);
                        if (asRoot) {
                            this.addRoot(allocationPointer);
                        }
                    } else {
                        console.error(`Collector.allocate: out of memory in allocating: (flat ${data.value})`);
                        return null;
                    }
                }
                break;
            case &quot;cons&quot;:
                if (this.spaceExists(3)) {
                    this.heap.heapSet(allocationPointer, &quot;cons&quot;);
                    this.heap.heapSet(allocationPointer + 1, data.root1);
                    this.heap.heapSet(allocationPointer + 2, data.root2);
                    this.heap.heapSet(2, allocationPointer + 3);
                    if (asRoot) {
                        this.addRoot(allocationPointer);
                    }
                } else {
                    let [newRoot1, newRoot2] = this.collectGarbage(data.root1, data.root2);
                    if (this.spaceExists(3)) {
                        allocationPointer = this.heap.heapGet(2);
                        this.heap.heapSet(allocationPointer, &quot;cons&quot;);
                        this.heap.heapSet(allocationPointer + 1, newRoot1);
                        this.heap.heapSet(allocationPointer + 1, newRoot2);
                        this.heap.heapSet(2, allocationPointer + 3);
                        if (asRoot) {
                            this.addRoot(allocationPointer);
                        }
                    } else {
                        console.error(`Collector.allocate: out of memory in allocating: (cons ${data.root1} ${data.root2})`);
                        return null;
                    }
                }
                break;
            default:
                console.error(`Collector.allocate: unknown tag: ${tag}`);
                return null;
        }

        return allocationPointer;
    }
}
</code></pre>





            </section>
        </article>

        <footer>
            

    <div>Powered by
        <a href="https://golang.org/">Go</a> and
        <a href="https://github.com/ellifteria/grafe">graf&emacr;</a>
    </div>


        </footer>
    </body>

</html>




